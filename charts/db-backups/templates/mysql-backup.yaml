{{- if .Values.mysql.enabled }}
# =============================================================================
# MYSQL BACKUP CRONJOB
# =============================================================================
# Sauvegarde automatique des bases MySQL (OpenMetadata, Airflow)
# Les backups sont compressés et envoyés vers MinIO
# =============================================================================

apiVersion: batch/v1
kind: CronJob
metadata:
  name: mysql-backup
  namespace: {{ .Values.global.namespace }}
  labels:
    app: db-backup
    database: mysql
spec:
  schedule: {{ .Values.mysql.schedule | quote }}
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 86400
      backoffLimit: 3
      template:
        metadata:
          labels:
            app: db-backup
            database: mysql
        spec:
          restartPolicy: OnFailure
          initContainers:
            # Step 1: Create MySQL dump
            - name: mysqldump
              image: {{ .Values.images.mysql.repository }}:{{ .Values.images.mysql.tag }}
              command:
                - /bin/bash
                - -c
                - |
                  set -e
                  echo "=== MySQL Backup Started at $(date) ==="
                  
                  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                  
                  {{- range .Values.mysql.databases }}
                  echo "Backing up database: {{ . }}"
                  mysqldump -h $MYSQL_HOST -P $MYSQL_PORT \
                    -u $MYSQL_USER -p"$MYSQL_PASSWORD" \
                    --single-transaction --routines --triggers \
                    {{ . }} > /backups/{{ . }}_${TIMESTAMP}.sql
                  
                  gzip /backups/{{ . }}_${TIMESTAMP}.sql
                  echo "Created: /backups/{{ . }}_${TIMESTAMP}.sql.gz"
                  {{- end }}
                  
                  echo "=== Backup files created ==="
                  ls -la /backups/
              env:
                - name: MYSQL_HOST
                  value: {{ .Values.mysql.host | quote }}
                - name: MYSQL_PORT
                  value: {{ .Values.mysql.port | quote }}
                - name: MYSQL_USER
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.mysql.credentials.secretName }}
                      key: {{ .Values.mysql.credentials.usernameKey }}
                - name: MYSQL_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.mysql.credentials.secretName }}
                      key: {{ .Values.mysql.credentials.passwordKey }}
              volumeMounts:
                - name: backup-data
                  mountPath: /backups
              resources:
                {{- toYaml .Values.mysql.resources | nindent 16 }}
          
          containers:
            # Step 2: Upload to MinIO
            - name: upload-to-minio
              image: {{ .Values.images.minio.repository }}:{{ .Values.images.minio.tag }}
              command:
                - /bin/sh
                - -c
                - |
                  set -e
                  echo "=== Uploading to MinIO ==="
                  
                  # Configure MinIO client
                  mc alias set backup http://{{ .Values.global.minio.endpoint }} "$MINIO_ACCESS_KEY" "$MINIO_SECRET_KEY"
                  
                  # Create bucket if not exists
                  mc mb --ignore-existing backup/{{ .Values.global.minio.bucket }}
                  mc mb --ignore-existing backup/{{ .Values.global.minio.bucket }}/mysql
                  
                  # Upload all backup files
                  for file in /backups/*.sql.gz; do
                    if [ -f "$file" ]; then
                      filename=$(basename "$file")
                      echo "Uploading: $filename"
                      mc cp "$file" backup/{{ .Values.global.minio.bucket }}/mysql/
                    fi
                  done
                  
                  # Cleanup old backups (keep last N)
                  echo "=== Cleanup old backups (keeping {{ .Values.mysql.retention.copies }}) ==="
                  mc ls backup/{{ .Values.global.minio.bucket }}/mysql/ | sort -r | tail -n +{{ add .Values.mysql.retention.copies 1 }} | awk '{print $NF}' | while read f; do
                    mc rm "backup/{{ .Values.global.minio.bucket }}/mysql/$f" 2>/dev/null || true
                  done
                  
                  echo "=== Current backups ==="
                  mc ls backup/{{ .Values.global.minio.bucket }}/mysql/
                  
                  echo "=== Backup complete! ==="
              env:
                - name: MINIO_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: minio-backup-credentials
                      key: access-key
                - name: MINIO_SECRET_KEY
                  valueFrom:
                    secretKeyRef:
                      name: minio-backup-credentials
                      key: secret-key
              volumeMounts:
                - name: backup-data
                  mountPath: /backups
          
          volumes:
            - name: backup-data
              emptyDir:
                sizeLimit: 5Gi
{{- end }}
